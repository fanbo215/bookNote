å¦‚æœå¯¹æ‰€æœ‰çš„èµ„æºçš„è®¿é—®éƒ½æ˜¯ç¬é—´æˆ–å¯ä»¥æ¥å—çš„æ—¶é—´å®Œæˆï¼Œé‚£ä¹ˆï¼Œç¨‹åºåªéœ€è¦æŒ‰ç…§é¡ºåºæ‰§è¡Œä¸‹æ¥å°±è¡Œäº†ï¼Œç”±äºè®¿é—®flashæˆ–ç½‘ç»œè¯·æ±‚ç­‰ä¼šéœ€è¦è¾ƒé•¿çš„æ—¶é—´æ‰èƒ½è¿”å›ï¼Œå¦‚æœå°†è¿™äº›è¯·æ±‚æ”¾åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œä¼šå¡ä½UIç•Œé¢ï¼Œé€ æˆappæ— æ³•åŠæ—¶å“åº”ç”¨æˆ·çš„è¡Œä¸ºï¼Œç”¨æˆ·ä½“éªŒä¸å¥½ï¼Œä¸ºäº†è®©ç¨‹åºèƒ½åŠæ—¶å“åº”ç”¨æˆ·çš„è¡Œä¸ºï¼Œéœ€è¦å°†è¿™äº›è€—æ—¶çš„æ“ä½œæ”¾åœ¨åˆ«çš„çº¿ç¨‹ï¼Œå½“å®ƒä»¬æ‰§è¡Œå®Œæˆåå†é€šçŸ¥ä¸»çº¿ç¨‹å¯¹ç»“æœè¿›è¡Œåç»­çš„å¤„ç†

* å¹¶å‘å’Œå¹¶è¡Œ
	* ç”±äºç°åœ¨æˆ‘ä»¬çš„è®¾å¤‡å¯èƒ½ä¸ä»…ä»…åªæœ‰ä¸€ä¸ªå¤„ç†å™¨ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†ä»»åŠ¡æ”¾åœ¨å¤šä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶æ‰§è¡Œï¼Œè¿™å°±æ˜¯æ‰€è°“çš„å¹¶è¡Œå¤„ç†ï¼Œå¹¶è¡Œæ˜¯éœ€è¦å¤šä¸ªå¤„ç†å™¨ï¼Œå³ç¡¬ä»¶çš„æ”¯æŒ
	* ç”±äºç°ä»£çš„æ“ä½œç³»ç»Ÿæ˜¯å¤šä»»åŠ¡ç³»ç»Ÿï¼Œå¯ä»¥åŒæ—¶å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œï¼Œå³æ‰€è°“çš„å¹¶å‘æ‰§è¡Œï¼Œå¹¶å‘æ˜¯éœ€è¦æ“ä½œç³»ç»Ÿæ”¯æŒï¼Œå³ç³»ç»Ÿè½¯ä»¶çš„æ”¯æŒ
	* å¯¹äºå¹¶å‘çš„çº¿ç¨‹ï¼Œå¦‚æœè¿è¡Œåœ¨å¤šå¤„ç†å™¨ä¸Šï¼Œå¯ä»¥å®ç°å¹¶è¡Œæ‰§è¡Œ

ä¸»çº¿ç¨‹ï¼ˆUIçº¿ç¨‹ï¼‰

çº¿ç¨‹æ˜¯ä¸€ä¸ªéå¸¸åº•å±‚çš„å·¥å…·ï¼Œä»–å°†çº¿ç¨‹çš„åˆ›å»ºï¼Œç®¡ç†ï¼ŒåŒæ­¥ç­‰äº¤ç»™äº†å¼€å‘äººå‘˜ï¼Œæé«˜äº†å¹¶å‘å¼€å‘çš„éš¾åº¦ï¼ŒåŒæ—¶æ— æ³•å‡†ç¡®è¯„ä¼°åˆ°åº•åˆ›å»ºå¤šå°‘çº¿ç¨‹æ‰åˆé€‚

æ–°çš„æ–¹å¼è®©å¼€å‘äººå‘˜åªå…³æ³¨éœ€è¦å¹¶å‘çš„ä»»åŠ¡æœ¬èº«ï¼Œå°†å‰©ä¸‹çš„äº‹æƒ…äº¤ç»™ç³»ç»Ÿæ¥å¤„ç†

å¼‚æ­¥å’ŒåŒæ­¥
åŒæ­¥æ˜¯æŒ‡ä¸€ä¸ªå‡½æ•°æˆ–blockï¼ˆé€šå¸¸æŒ‡ä»»åŠ¡ï¼‰åœ¨å…¶è‡ªèº«è¿˜æ²¡æœ‰æ‰§è¡Œå®Œæ—¶æ˜¯ä¸ä¼šè¿”å›çš„ï¼Œå¼‚æ­¥æŒ‡å®ƒä»¬è¿˜æ²¡æœ‰æ‰§è¡Œå®Œå°±å¯ä»¥è¿”å›ï¼Œæ²¡æœ‰æ‰§è¡Œå®Œçš„ä»»åŠ¡è¿˜å¯ä»¥ç»§ç»­æ‰§è¡Œ

å¼‚æ­¥ä¸å¹¶å‘ï¼Œå¼‚æ­¥æœºåˆ¶åˆ©ç”¨å¤šçº¿ç¨‹å®ç°ï¼Œå¹¶å‘ä¹Ÿåˆ©ç”¨å¤šçº¿ç¨‹ï¼Œä½†æ˜¯å¼‚æ­¥ä¹Ÿå¯èƒ½æ˜¯åœ¨åŒä¸€ä¸ªçº¿ç¨‹é¡ºåºæ‰§è¡Œ
å¼‚æ­¥æ˜¯å¯¹å¤šçº¿ç¨‹çš„å°è£…ï¼Œå¹¶å‘æ˜¯åˆ©ç”¨å¤šçº¿ç¨‹

GCD
dispatch queueæ˜¯åŸºäºcçš„ç”¨äºæ‰§è¡Œè‡ªå®šä¹‰ä»»åŠ¡çš„æœºåˆ¶ï¼Œä¸ç®¡æ˜¯å¹¶å‘é˜Ÿåˆ—è¿˜æ˜¯ä¸²è¡Œé˜Ÿåˆ—ï¼Œå®ƒä»¬éƒ½æ˜¯å…ˆè¿›å…ˆå‡º
æœ‰ç‚¹ï¼š
1. æ¥å£ç®€å•
2. æä¾›è‡ªåŠ¨è€Œå…¨é¢çš„çº¿ç¨‹ç®¡ç†
3. è¿›è¡Œäº†ç»†è‡´çš„ä¼˜åŒ–
4. å†…å­˜åˆ©ç”¨ç‡é«˜
5. åœ¨åŠ è½½æ—¶ä¸ä¼šé™·å…¥å†…æ ¸
6. å¼‚æ­¥çš„dispatch queueä¸ä¼šæ­»é”é˜Ÿåˆ—
7. ä¸²è¡Œé˜Ÿåˆ—æ¯”é”å’Œå…¶å®ƒåŒæ­¥æœºåˆ¶æ•ˆç‡é«˜
ä¸²è¡Œé˜Ÿåˆ—æŒ‰ç…§å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™ä¸€æ¬¡åªæ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œè¿™äº›ä»»åŠ¡å¯ä»¥è¿è¡Œåœ¨ä¸åŒçš„çº¿ç¨‹ï¼Œä¸»è¦ç”¨äºåŒæ­¥è®¿é—®ç‰¹å®šèµ„æº
å¯ä»¥åˆ›å»ºå¤šä¸ªä¸²è¡Œé˜Ÿåˆ—ï¼Œæ¯ä¸ªé˜Ÿåˆ—å¯ä»¥å¹¶å‘æ‰§è¡Œï¼Œå¦‚4ä¸ªä¸²è¡Œé˜Ÿåˆ—ï¼Œæ¯ä¸ªé˜Ÿåˆ—ä¸€ä¸ªä»»åŠ¡ï¼Œé‚£ä¹ˆè¿™å››ä¸ªä»»åŠ¡å¯ä»¥å¹¶å‘æ‰§è¡Œ
å¹¶å‘é˜Ÿåˆ—å¯ä»¥æ‰§è¡Œä¸€ä¸ªæˆ–å¤šä¸ªä»»åŠ¡ï¼Œä»»åŠ¡ä»ç„¶æ˜¯æŒ‰ç…§å…ˆè¿›å…ˆå‡ºçš„åŸåˆ™å¼€å§‹
main dispatch queueæ˜¯ä¸€ä¸ªå…¨å±€çš„ä¸²è¡Œé˜Ÿåˆ—ï¼Œç”¨æ¥åœ¨ä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œä»»åŠ¡
ç³»ç»Ÿå¯ä»¥æ ¹æ®å½“å‰ç³»ç»Ÿç¯å¢ƒåŠ¨æ€å†³å®šåˆ†é…å¤šå°‘çº¿ç¨‹ï¼Œå¹¶ä¸”æ¯”æ‰‹åŠ¨åˆ›å»ºçº¿ç¨‹æ‰§è¡Œä»»åŠ¡è¦å¿«
å¯¹äºåœ¨blockä¸­è¦åˆ›å»ºå¤§é‡çš„ocå¯¹è±¡ï¼Œå¯ä»¥è€ƒè™‘åœ¨blockå¼€å§‹å¤„åŠ å…¥@autorelease blcok
å¯ä»¥ä¸ºdispatchæ·»åŠ contextæ•°æ®

```
void myFinalizerFunction(void *context)
  {
	MyDataContext* theData = (MyDataContext*)context;
      // Clean up the contents of the structure
      myCleanUpDataContextFunction(theData);
      // Now release the structure itself.
      free(theData);
  }
  dispatch_queue_t createMyQueue()
  {
      MyDataContext*  data = (MyDataContext*) malloc(sizeof(MyDataContext));
      myInitializeDataContextFunction(data);
      // Create the queue and set the context data.
      dispatch_queue_t serialQueue =
  dispatch_queue_create("com.example.CriticalTaskQueue", NULL);
      if (serialQueue)
      {
          dispatch_set_context(serialQueue, data);
          dispatch_set_finalizer_f(serialQueue, &myFinalizerFunction);
      }
      return serialQueue;
  }. 

dispatch_syncå’Œdispatch_sync_få‡½æ•°ä¼šé˜»å¡å½“å‰çº¿ç¨‹çš„æ‰§è¡Œï¼Œç›´åˆ°è¿™ä¸ªä»»åŠ¡è¢«æ‰§è¡Œå®Œæˆ
æ³¨æ„ï¼Œå¦‚æœåœ¨ä¸€ä¸ªä¸²è¡Œé˜Ÿåˆ—ä¸­è°ƒè¿™è¿ä¸ªå‡½æ•°è‚¯å®šä¼šå¯¼è‡´æ­»é”ï¼Œå¯¹äºå¹¶å‘é˜Ÿåˆ—ä¹Ÿè¦é¿å…è¿™æ ·è°ƒç”¨

dispatch_queue_t myCustomQueue;
myCustomQueue = dispatch_queue_create("com.example.MyCustomQueue", NULL);
dispatch_async(myCustomQueue, ^{
    printf("Do some work here.\n");
});
printf("The first block may or may not have run.\n");
dispatch_sync(myCustomQueue, ^{
    printf("Do some more work here.\n");
});
printf("Both blocks have completed.\n"); //å› ä¸ºå‰é¢ä¸€ä¸ªè°ƒç”¨æ˜¯åŒæ­¥è°ƒç”¨ï¼Œæ‰€ä»¥ä¼šå…ˆæ‰§è¡Œå®ƒé‡Œé¢çš„å†…å®¹ï¼Œåˆç”±äºé˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºï¼Œæ‰€ä»¥ï¼Œé˜Ÿåˆ—ä¹‹å‰çš„ä»»åŠ¡ä¹Ÿä¼šæ‰§è¡Œ
void average_async(int *data, size_t len,
   dispatch_queue_t queue, void (^block)(int))
{
   // Retain the queue provided by the user to make
   // sure it does not disappear before the completion
   // block can be called.
   dispatch_retain(queue);
   // Do the work on the default concurrent queue and then
   // call the user-provided block with the results.
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
^{
      int avg = average(data, len);
      dispatch_async(queue, ^{ block(avg);});
      // Release the user-provided queue when done
      dispatch_release(queue);
   });
}

dispatch_applyå¯ä»¥å…è®¸å°†ä¸€ä¸ªblockæäº¤åˆ°dispatch queueå¤šæ¬¡ï¼Œå¦‚æœæ˜¯ä¸²è¡Œé˜Ÿåˆ—å°±æ˜¯é¡ºåºæ‰§è¡Œï¼Œå¦‚æœæ˜¯å¹¶è¡Œé˜Ÿåˆ—å°±æ˜¯å¹¶å‘æ‰§è¡Œï¼Œå¯ä»¥ç”¨äºforå¾ªç¯ï¼Œå®ƒææœ‰å¯èƒ½ä¼šç»„å¡å½“å‰çº¿ç¨‹ï¼Œå› æ­¤è¦ç‰¹åˆ«æ³¨æ„ä¸è¦æ”¾åœ¨ä¸»çº¿ç¨‹ä¸Šï¼Œå¦å¤–ï¼Œä¹Ÿä¸è¦åœ¨ä¸²è¡Œé˜Ÿåˆ—çš„ç¯å¢ƒä¸­ç”¨åŒä¸€ä¸ªé˜Ÿåˆ—æ¥è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œææœ‰å¯èƒ½é€ æˆæ­»é”
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   printf("%u\n",i);
});

å¦‚æœä½ åˆ›å»ºçš„ä¸æ˜¯cocoaåº”ç”¨ç¨‹åºå¹¶ä¸”æ²¡æœ‰è®¾ç½®runloopï¼Œå¿…é¡»è°ƒç”¨dispatch_mainå‡½æ•°æ¥æ˜¾å¼drainä¸»dispatch queueï¼Œå¦åˆ™é‡Œé¢çš„ä»»åŠ¡æ˜¯ä¸èƒ½è¢«æ‰§è¡Œçš„

æŒ‚èµ·å’Œå›å¤dispatch queueï¼Œdispatch_suspendå’Œdispatch_resume

ä½¿ç”¨dispatch semaphoreæ¥æ§åˆ¶ä½¿ç”¨æœ‰é™èµ„æº
å¯¹äºæœ‰èµ„æºå¯ç”¨çš„æƒ…å†µï¼Œéœ€è¦æ›´å°‘çš„æ—¶é—´æ¥è·å–ä¿¡å·é‡
1. å½“åˆ›å»ºä¿¡å·æ—¶ï¼Œdispatch_semaphore_createï¼Œå¯ä»¥ç”¨æ¥æè¿°å¤šå°‘èµ„æºå¯ç”¨
2. åœ¨æ¯ä¸ªä»»åŠ¡ä¸­è°ƒç”¨dispatch_semaphore_waitæ¥ç­‰å¾…ä¿¡å·
3. å½“ç­‰å¾…è¿”å›æ—¶ï¼Œè¡¨ç¤ºè·å–åˆ°èµ„æºï¼Œå¯ä»¥æ‰§è¡Œä»»åŠ¡
4. å½“ä½¿ç”¨å®Œèµ„æºï¼Œé‡Šæ”¾å®ƒï¼Œå¹¶è°ƒç”¨dispatch_semaphore_signalå¢åŠ ä¿¡å·é‡å€¼
å½“è°ƒç”¨dispatch_semaphore_waitæ—¶ï¼Œä¿¡å·é‡ä¼šï¼1ï¼Œå¦‚æœå€¼ä¸ºè´Ÿï¼Œå†…æ ¸ä¼šé˜»å¡è¯¥çº¿ç¨‹ï¼Œdispatch_semaphore_signalä¼šå°†ä¿¡å·é‡ï¼‹1ï¼Œå¦‚æœæœ‰ä»»åŠ¡é˜»å¡å¹¶ç­‰å¾…èµ„æºï¼Œå…¶ä¸­ä¸€ä¸ªè¢«é˜»å¡çš„ä»»åŠ¡å¯ä»¥ç»§ç»­æ‰§è¡Œäº†

dispatch groupæ˜¯ä¸€ç§é˜»å¡çº¿ç¨‹çš„æ–¹å¼ï¼Œåªæœ‰å½“å®ƒé‡Œé¢çš„ä»»åŠ¡ç»“æŸæ‰§è¡Œåæ‰ä¼šå–æ¶ˆé˜»å¡ã€‚å¯¹äºè¿™äº›ä»»åŠ¡ä¸åœ¨åŒä¸€ä¸ªé˜Ÿåˆ—ä¹Ÿå¯ä»¥è¿½è¸ª
-(void)fetchConfigurationWithCompletion:(void (^)(NSError* error))completion
{
    // Define errors to be processed when everything is complete.
    // One error per service; in this example we'll have two 
    __block NSError *configError = nil;
    __block NSError *preferenceError = nil;

    // Create the dispatch group
    dispatch_group_t serviceGroup = dispatch_group_create();

    // Start the first service
    dispatch_group_enter(serviceGroup);
    [self.configService startWithCompletion:^(ConfigResponse *results, NSError* error){
        // Do something with the results
        configError = error;
        dispatch_group_leave(serviceGroup);
    }];

    // Start the second service
    dispatch_group_enter(serviceGroup);
    [self.preferenceService startWithCompletion:^(PreferenceResponse *results, NSError* error){
        // Do something with the results
        preferenceError = error;
        dispatch_group_leave(serviceGroup);
    }];

    dispatch_group_notify(serviceGroup,dispatch_get_main_queue(),^{
        // Assess any errors
        NSError *overallError = nil;
        if (configError || preferenceError)
        {
            // Either make a new error or assign one of them to the overall error
            overallError = configError ?: preferenceError;
        }
        // Now call the final completion block
        completion(overallError);
    });
}



dispatch sourceä¹Ÿæ˜¯åŸºäºcçš„å¼‚æ­¥å¤„ç†ç³»ç»Ÿäº‹ä»¶çš„æœºåˆ¶ï¼Œå®ƒå°è£…äº†ç³»ç»Ÿçš„äº‹ä»¶ï¼Œå½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œä¼šæäº¤ä¸€ä¸ªç”¨æˆ·çš„blockç»™dispatch queueï¼Œç”¨å®ƒå¯ä»¥å–ä»£å¼‚æ­¥å›è°ƒå‡½æ•°ï¼Œå¯ä»¥ç”¨äºç›‘æ§å¦‚ä¸‹ç³»ç»Ÿäº‹ä»¶ï¼š
1. å®šæ—¶å™¨
2. ä¿¡å·å¥æŸ„
3. æè¿°ç¬¦ç›¸å…³çš„äº‹ä»¶
4. è¿›ç¨‹ç›¸å…³çš„äº‹ä»¶
5. mach portäº‹ä»¶
6. ç”¨æˆ·å®šä¹‰çš„äº‹ä»¶
åˆ›å»ºdispatch sourceçš„æ­¥éª¤
1. åˆ›å»ºdispatch sourceï¼Œdispatch_source_create;
2. é…ç½®dispatch source:
	* ç»™dispatch sourceè®¾ç½®äº‹ä»¶å¤„ç†å‡½æ•°ï¼›
	* å¯¹äºæ—¶é—´æºï¼Œç”¨dispatch_source_set_timer
3. å¯é€‰è®¾ç½®å–æ¶ˆdispatch sourceå‡½æ•°;
4. è°ƒç”¨dispatch_resumeå‡½æ•°å¼€å§‹å¤„ç†äº‹ä»¶
å½“äº‹ä»¶å¤„ç†å·²ç»è¢«æ’é˜Ÿå¹¶ç­‰å¾…å¤„ç†äº‹ä»¶æ—¶å¯¹äºæ–°åˆ°æ¥çš„äº‹ä»¶ï¼Œdispatch sourceä¼šå°†è¿™ä¸¤ä¸ªäº‹ä»¶åˆå¹¶ï¼Œå…·ä½“çš„æƒ…å†µè¦è§†äº‹ä»¶ç±»å‹è€Œå®š
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
                                 myDescriptor, 0, myQueue);
dispatch_source_set_event_handler(source, ^{
   // Get some data from the source variable, which is captured
   // from the parent context.
   size_t estimated = dispatch_source_get_data(source);
   // Continue reading the descriptor...
});
dispatch_resume(source);
å½“ç”µè„‘ç¡çœ æ—¶ï¼Œæ‰€æœ‰çš„å®šæ—¶å™¨dispatch sourceä¼šè¢«æŒ‚èµ·ã€‚å½“ç”µè„‘å”¤é†’æ—¶ï¼Œé‚£äº›å®šæ—¶å™¨ä¼šè‡ªåŠ¨å”¤é†’ã€‚

Operation Queue
æ˜¯é¢å‘å¯¹è±¡çš„dispatch queueï¼Œå¯¹äºä»»åŠ¡çš„æ‰§è¡Œé¡ºåºå¯ä»¥è‡ªå®šä¹‰ï¼Œåœ¨å®šä¹‰ä»»åŠ¡æ—¶è®¾ç½®å¥½ä¾èµ–å…³ç³»å°±èƒ½åˆ›é€ å¤æ‚çš„æ‰§è¡Œé¡ºåº
Operationå¯¹è±¡å¯ä»¥ç”Ÿæˆkvoé€šçŸ¥ï¼Œç”¨æ¥ç›‘æ§ä»»åŠ¡çš„è¿›åº¦

Operationç”±NSOperationæè¿°ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œéœ€è¦è¢«ç»§æ‰¿åæ‰èƒ½ä½¿ç”¨ï¼Œè¯¥ç±»æä¾›äº†è¦å®ç°ä¸€ä¸ªæ“ä½œæ‰€éœ€çš„å¤§é‡å·¥ä½œ
NSInvocationOperationå¯ä»¥åˆ©ç”¨å·²æœ‰çš„ç±»å’Œæ¥å£æ¥åˆ›å»ºä¸€ä¸ªoperationå¯¹è±¡
NSBlockOperationå¯ä»¥ç”¨æ¥æ‰§è¡Œä¸€ä¸ªæˆ–å¤šä¸ªblockï¼Œåªæœ‰å½“å¤šä¸ªblockéƒ½æ‰§è¡Œå®Œï¼Œè¿™ä¸ªæ“ä½œæ‰ç®—æ‰§è¡Œå®Œ
å¥½å¤„ï¼š
æ”¯æŒæ“ä½œå¯¹è±¡é—´åŸºäºå›¾çš„ä¾èµ–ï¼Œè¯¥ä¾èµ–é˜»æ­¢ä¸€ä¸ªæ“ä½œæ‰§è¡Œï¼Œç›´åˆ°ä¸å®ƒä¾èµ–çš„æ“ä½œæ‰§è¡Œå®Œ
æ”¯æŒåœ¨ä¸»è¦ä»»åŠ¡å®Œæˆåæä¾›ä¸€ä¸ªå¯é€‰çš„å®Œæˆblock
æ”¯æŒé€šè¿‡kvoé€šçŸ¥æ¥ç›‘æ§æ“ä½œæ‰§è¡ŒçŠ¶æ€çš„æ”¹å˜
æ”¯æŒé€šè¿‡ä¼˜å…ˆçº§æ¥å½±å“ç›¸å…³æ‰§è¡Œçš„é¡ºåº
æ”¯æŒå–æ¶ˆæ‰§è¡Œè¯­æ„ï¼Œå…è®¸ä½ åœæ­¢æ‰§è¡Œä¸€ä¸ªæ­£åœ¨æ‰§è¡Œçš„æ“ä½œ
NSInvocationOperationä½¿ç”¨

```
- (NSOperation *)taskWithData:(id)data {
	NSInvocationOperation *theOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTaskMethod:) object:data];
	return theOp;
}
- (void)myTaskMethod:(id)data {
	// perform the task;
}
```

NSBlockOperationä½¿ç”¨

```
NSBlockOperation *theOp = [NSBlockOperation blockOperationWithBlock: ^{
	NSLog("Beginning operation. \n");
	// do some work
}];
```

å¦‚æœæ˜¯è¦æ·»åŠ æ›´å¤šblockï¼Œé‡‡ç”¨addExecutionBlcok:æ–¹æ³•
è‡ªå®šä¹‰æ“ä½œéœ€è¦å®ç°æ–¹æ³•
1. è‡ªå®šä¹‰åˆå§‹åŒ–æ“ä½œï¼Œç”¨äºè®¾ç½®æ“ä½œçš„çŠ¶æ€
2. mainï¼Œè¦æ‰§è¡Œçš„ä»»åŠ¡

```
@interface MyNonConcurrentOperation : NSOperation
@property id (strong) myData;
-(id)initWithData:(id)data;
@end
@implementation MyNonConcurrentOperation
- (id)initWithData:(id)data {
   if (self = [super init])
      myData = data;
   return self;
}
-(void)main {
   @try {
      // Do some work on myData and report the results.
   }
   @catch(...) {
      // Do not rethrow exceptions.
} }
@end
```

å“åº”å–æ¶ˆï¼Œéœ€è¦å‘¨æœŸæ€§çš„è°ƒç”¨isCancelledæ–¹æ³•ï¼Œå¦‚æœä¸ºYESï¼Œåˆ™ç«‹å³ç»“æŸï¼Œè¿™äº›åœ°æ–¹åŒ…æ‹¬
1. åœ¨æ‰§è¡Œå…·ä½“çš„ä»»åŠ¡å‰
2. åœ¨æ¯ä¸ªå¾ªç¯å‰ï¼Œæˆ–è€…æ¯ä¸€ä¸ªéå†å‰
3. åœ¨æ¯”è¾ƒé€‚åˆä¸­æ–­æ“ä½œæ—¶

```
- (void)main {
   @try {
      BOOL isDone = NO;
      while (![self isCancelled] && !isDone) {
          // Do some work and set isDone to YES when finished
} }
   @catch(...) {
      // Do not rethrow exceptions.
} }
```

å¯¹äºå¹¶å‘çš„æ“ä½œï¼Œéœ€è¦è¦†ç›–çš„å®ç°ï¼š
|:------æ–¹æ³•---------|:-----------æè¿°-----------------|
|start---------------| å¿…é¡»è¦†å†™ï¼Œæ‰‹åŠ¨æ‰§è¡Œéœ€è¦è°ƒstartæ–¹æ³•, ä¸ç”¨è°ƒsuper startï½œ
|main----------------| å¯é€‰ï¼Œç”¨æ¥å®ç°ä»»åŠ¡|
|isExecuting, isFinished| å¿…é¡»è¦†å†™ï¼Œç”±ç”¨æˆ·æ¥æŠ¥å‘ŠçŠ¶æ€|
|isConcurrent--------| å¿…é¡»è¦†å†™ï¼Œæ ‡ç¤ºæ“ä½œæ˜¯å¦å¹¶å‘|

```
@interface MyOperation : NSOperation {
      BOOL        executing;
      BOOL        finished;
ï¿¼ï¿¼ï¿¼ï¿¼}
- (void)completeOperation;
@end
@implementation MyOperation
- (id)init {
    self = [super init];
    if (self) {
        executing = NO;
        finished = NO;
    }
    return self;
}
- (BOOL)isConcurrent {
    return YES;
}
- (BOOL)isExecuting {
    return executing;
}
- (BOOL)isFinished {
    return finished;
}
@end

- (void)start {
   // Always check for cancellation before launching the task.
   if ([self isCancelled])
   {
      // Must move the operation to the finished state if it is canceled.
      [self willChangeValueForKey:@"isFinished"];
      finished = YES;
      [self didChangeValueForKey:@"isFinished"];
return; }
   // If the operation is not canceled, begin executing the task.
[self willChangeValueForKey:@"isExecuting"];
[NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
   executing = YES;
   [self didChangeValueForKey:@"isExecuting"];
}

- (void)main {
   @try {
       // Do the main work of the operation here.
       [self completeOperation];
   }
   @catch(...) {
      // Do not rethrow exceptions.
} }
- (void)completeOperation {
    [self willChangeValueForKey:@"isFinished"];
    [self willChangeValueForKey:@"isExecuting"];
    executing = NO;
    finished = YES;
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
}
```

å¯¹äºæ“ä½œé—´çš„ä¾èµ–ï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨addDependency:æ¥å»ºç«‹ã€‚è¡¨ç¤ºè°ƒç”¨çš„æ“ä½œä¾èµ–å‚æ•°æ“ä½œï¼Œå³è°ƒç”¨çš„æ“ä½œä¸ä¼šæ‰§è¡Œï¼Œç›´åˆ°å‚æ•°æ“ä½œç»“æŸæ‰§è¡Œï¼Œè¿™ç§ä¾èµ–ä¸å±€é™åœ¨åŒä¸€ä¸ªqueueä¸­ï¼Œä½†æ˜¯è¦æ³¨æ„é¿å…å¾ªç¯ä¾èµ–ï¼Œå½“æ‰€æœ‰çš„æ“ä½œä¾èµ–éƒ½æ‰§è¡Œå®Œæˆï¼Œè¯¥æ“ä½œå°†å˜ä¸ºreadyçŠ¶æ€ï¼Œæ³¨æ„ï¼šä¾èµ–å¿…é¡»åœ¨è¿è¡Œæ“ä½œæˆ–æ·»åŠ å®ƒä»¬åˆ°operation queueå‰æ·»åŠ 

å¯¹äºä¸€ä¸ªæ·»åŠ åˆ°operation queueçš„æ“ä½œï¼Œæ‰§è¡Œçš„é¡ºåºå–å†³ä¸æ“ä½œçš„readyçŠ¶æ€å’Œè‡ªå·±çš„ä¼˜å…ˆçº§ï¼Œé»˜è®¤è‡ªå·±çš„ä¼˜å…ˆçº§æ˜¯normalï¼Œå¯ä»¥é€šè¿‡setQueuePriority:æ¥è®¾ç½®ï¼Œä¼˜å…ˆçº§ğŸˆ¯ï¸é™åœ¨åŒä¸€ä¸ªqueueä¸­ï¼Œ
å¯ä»¥è®¾ç½®æ“ä½œæ‰€åœ¨çº¿ç¨‹çš„ä¼˜å…ˆçº§ï¼ŒsetThreadPriority:

é€šè¿‡setCompletionBlock:æ¥è®¾ç½®å®Œæˆblock

é¿å…åœ¨çº¿ç¨‹ä¸­å­˜å‚¨æˆ–ä¼ é€’æ•°æ®
æ“ä½œéœ€è¦è‡ªå·±å¼•ç”¨
æ·»åŠ é”™è¯¯å’Œå¼‚å¸¸å¤„ç†

å¯¹äºæ“ä½œï¼Œå»ºè®®å¤„ç†æ¯”è¾ƒè€—æ—¶çš„æ“ä½œï¼Œè€Œä¸æ˜¯æå…¶çŸ­æš‚çš„æ“ä½œ

æ·»åŠ ä¸€ä¸ªæ“ä½œåˆ°operation queue

```
NSOperationQueue *aQueue = [[NSOperationQueue alloc] init]; 
[aQueue addOperation:anOp]; // Add a single operation
[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations [aQueue addOperationWithBlock:^{
   /* Do something. */
}];
```

æ°¸è¿œä¸è¦å°†æ“ä½œæ·»åŠ åˆ°é˜Ÿåˆ—åå†ä¿®æ”¹æ“ä½œ

```
  - (BOOL)performOperation:(NSOperation*)anOp
  {
     BOOL        ranIt = NO;
     if ([anOp isReady] && ![anOp isCancelled])
     {
        if (![anOp isConcurrent])
           [anOp start];
        else
           [NSThread detachNewThreadSelector:@selector(start)
                     toTarget:anOp withObject:nil];
ranIt = YES; }
     else if ([anOp isCancelled])
     {
        // If it was canceled before it was started,
	//  move the operation to the finished state.
        [self willChangeValueForKey:@"isFinished"];
        [self willChangeValueForKey:@"isExecuting"];
        executing = NO;
        finished = YES;
        [self didChangeValueForKey:@"isExecuting"];
        [self didChangeValueForKey:@"isFinished"];
        // Set ranIt to YES to prevent the operation from
        // being passed to this method again in the future.
        ranIt = YES;
}
     return ranIt;
 }

NSOperationå¯ä»¥å•ç‹¬æ‰§è¡Œï¼Œä¹Ÿå¯ä»¥æ”¾åœ¨operation queueä¸­æ‰§è¡Œï¼Œå¹¶ä¸”å¯ä»¥è®¾ç½®åŒæ­¥æˆ–å¼‚æ­¥ï¼Œé»˜è®¤æ˜¯åŒæ­¥ï¼Œæ³¨æ„åŒæ­¥å¼‚æ­¥æ˜¯é’ˆå¯¹è°ƒç”¨è¯¥å¯¹è±¡startå¯¹åº”çš„çº¿ç¨‹è€Œè¨€çš„ï¼Œå¹¶ä¸”è¡¨æ˜è¯¥è°ƒç”¨æ˜¯å¦è¦ç«‹å³è¿”å›ï¼Œä¸å¹¶å‘æ— å…³ï¼Œå¦‚æœè¦å®ç°å¹¶å‘çš„æ“ä½œï¼Œéœ€è¦å†åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œè°ƒç”¨å¼‚æ­¥çš„ç³»ç»Ÿå‡½æ•°æˆ–ç¡®ä¿startå‡½æ•°èƒ½ç«‹å³è¿”å›çš„æ¥å£ï¼Œå½“ç„¶é€šå¸¸å¼€å‘è€…ä¸éœ€è¦æ˜¯å®ç°å¹¶å‘çš„æ“ä½œã€‚

å¹¶å‘è®¾è®¡
å®šä¹‰æ‰€æœ‰çš„è¡Œä¸º
æ ¹æ®å‰é¢çš„è¡Œä¸ºåˆ¤æ–­æ˜¯æ²¡æœ‰å…ˆåé¡ºåºçš„è¡Œä¸ºé‡‡ç”¨å¹¶å‘ï¼Œå…ˆåé¡ºåºä¼šå½±å“ç»“æœçš„é‡‡ç”¨åºåˆ—ï¼Œæ­¤æ—¶å¯ä»¥å°†è¡Œä¸ºç»†åˆ†ä¸ºæ›´å°çš„æ‰§è¡Œå•å…ƒ
åŒºåˆ†å‡ºä¸åŒä»»åŠ¡æ”¾åœ¨ä¸åŒçš„é˜Ÿåˆ—
ç‰¹åˆ«æ³¨æ„çš„åœ°æ–¹ï¼š
å¦‚æœå†…å­˜ä½¿ç”¨å¤ªå¤šï¼Œå¯ä»¥è€ƒè™‘åœ¨ä»»åŠ¡ä¸­ç›´æ¥è®¡ç®—å€¼
å°½æ—©è¯†åˆ«å‡ºä¸²è¡Œä»»åŠ¡ï¼Œè®©å®ƒèƒ½å°½å¯èƒ½çš„å¹¶è¡Œ
é¿å…ä½¿ç”¨é”
å¤šä¾èµ–ç³»ç»Ÿå¹¶å‘åº“

å¯¹äºæ¶‰åŠåˆ°å¤§é‡æ•°å­—å¹¶è¡Œè®¡ç®—çš„å¯ä»¥è€ƒè™‘é‡‡ç”¨OpenCLï¼ˆopen computing languageï¼‰

